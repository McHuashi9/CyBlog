---
title: P2440 木材加工
date: 2025-11-30 17:58:22
tags:
  - 二分
  - 洛谷
---

# P2440 木材加工

## 题目背景

要保护环境。

## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。

## 输入格式

第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。

接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。

## 输出格式

仅一行，即 $l$ 的最大值。

如果连 $\text{1cm}$ 长的小段都切不出来，输出 `0`。

## 输入输出样例 #1

### 输入 #1

```
3 7
232
124
456
```

### 输出 #1

```
114
```

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。

## 思路分析 + 代码实现

发现比较容易判断一个 $l$ 是否合法，再加上这道题答案具有“单调性”，因此采取二分答案的方式，找到最大的合法的 $l$ ，时间复杂度为 $O(n\operatorname{log}n)$ ，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int MAXN = 1e5 + 5;
int a[MAXN];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, k, ans = 0;
    cin >> n >> k;
    for(int i = 0; i < n; i++)
        cin >> a[i];
    int l = 0, r = 1e8;
    while (l <= r) {
        int mid = (l + r) / 2, sum = 0;
        if (mid == 0) {ans = 0; break;}
        for(int i = 0; i < n; i++)
            sum += a[i] / mid;
        if (sum < k) r = mid - 1;
        else {ans = mid; l = mid + 1;}
    }
    cout << ans;
    return 0;
}
```
